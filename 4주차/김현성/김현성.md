# 4주차 React 스터디 정리

| 장   | 제목                             |
| ---- | -------------------------------- |
| 9장  | 컴포넌트 스타일링                |
| 10장 | 일정 관리 웹 어플리케이션 만들기 |
| 11장 | 컴포넌트 성능 최적화             |



## 9장

### 9.1 가장 흔한 방식, 일반 CSS

css를 작성할 때 가장 중요한 점은 css 클래스를 **중복되지 않게** 많드는 것.

1. 이름을 지을 때 특별한 규칙을 사용하여 짓기

   → App.css 를 참고하면, 클래스 이름이 컴포넌트 이름-클래스 형태로 지어져 있는 것을 볼 수 있음.

   → 클래스 이름에 컴포넌트 이름을 포함시킴으로써 다른 컴포넌트에서 실수로 중복되는 클래스를 만들어 사용하는 것을 방지할 수 있음.

   → BEM 네이밍: css 방법론 중 하나로, 이름을 지을 때 일종의 규칙을 준수하여 해당 클래스가 어디에서 어떤 용도로 사용되는지 명확하게 작성하는 방식.



2. CSS Selector 활용하기

   → CSS 클래스가 특정 클래스 내부에 있는 경우에만 스타일을 적용할 수 있음.

   

실습 결과

<img src="C:\Users\ddffs\AppData\Roaming\Typora\typora-user-images\image-20211008170704238.png" alt="image-20211008170704238" style="zoom: 50%;" />



### 9.2 Sass 사용하기

Sass(Syntactically Awesome Style Sheets): CSS 전처리기로, 복잡한 작업을 쉽게 할 수 있도록 해주고 스타일 코드의 재활용성을 높여 줄 뿐만 아니라 코드의 가독성을 높여서 유지 보수를 더욱 쉽게 해줌.

`.scss` `.sass` 라는 두 가지 확장자를 지원하는데, 이 두개의 문법은 꽤 다름 !

**.sass**

```
$font-stack: Helvetica, sans-serif
$primary-color: #333

body {
	font: 100% $font-stack
	color: $primary-color
}
```

**.scss**

```
$font-stack: Helvetica, sans-serif
$primary-color: #333;

body {
	font: 100% $font-stack;
	color: $primary-color;
}
```

`.sass`는 중괄호와 세미콜론을 사용하지 않음.

`.scss`는 기존 css의 작성 방식과 크게 다르지 않음.



scss 파일 내에서 다른 scss 파일을 불러올 때는 @import 구문을 사용함.



Sass의 장점 중 하나인 라이브러리를 쉽게 불러와서 사용할 수 있는 점을 이용하기 위해 상대 경로를 사용하면, 스타일 파일이 깊숙한 디렉터리에 위치할 경우 ../를 매우 많이 적어야 해서 번거로움.

그래서 사용하는 것이 `물결 문자(~)` !

```@import '~library/styles';``` 

이렇게 물결 문자를 사용하면 자동으로 node_modules에서 라이브러리 디렉터리를 탐지하여 스타일을 불러올 수 있음. 



### 9.3 CSS Module

`CSS Module` 이란 CSS를 불러와서 사용할 때 클래스 이름을 고유한 값, 즉 `[파일 이름]_[클래스 이름]_[해시값]` 형태로 자동으로 만들어서 *컴포넌트 스타일 클래스 이름이 중첩되는 현상을 방지* 해 주는 기술.

그러므로, CSS Module을 사용하면 클래스 이름을 지을 때 그 고유성에 대해 고민하지 않아도 됨.

if) 특정 클래스가 웹 페이지에서 전역적으로 사용되는 경우라면 `:global` 을 앞에 입력해서 글로벌 CSS임을 명시해 줄 수 있음.



요 CSS Module이 적용된 스타일 파일을 불러오게 되면, 객체를 하나 전달받게 됨.

바로바로 CSS Module에서 사용한 클래스 이름과 해당 이름을 고유화한 값이 키-값 형태로 들어 있음 . 



`classnames`는 CSS 클래스를 조건부로 설정할 때 매우 유용한 라이브러리.

CSS Module 을 사용할 때 이 라이브러리를 사용하면 여러 클래스를 적용할 때 매우 편리하대

(이러한 라이브러리의 도움을 받지 않는 경우보다 classnames 쓰는 것이 가독성 훨 좋음.)

```react
const MyComponent = ({ highlighted, theme }) => (
	<div className={classNames('MyComponent', { highlighted }, theme)}>Hello</div>
);
```

위의 코드의 경우, 위 엘리먼트의 클래스에 highlighted 값이 true이면 highlighted 클래스가 적용되고, false이면 적용되지 않음.

또한, theme으로 전달받는 문자열은 내용 그대로 클래스에 적용됨.



Sass를 사용할 때도 파일 이름 뒤에 .module.scss 확장자를 사용해주면 CSS Modules로 사용할 수 있음.



CSS Module이 아닌 일반 .css / .scss 파일에서도 :local을 사용해서 CSS Module 사용 가능!



### 9.4 styled-components

CSS-in-JS: 자바스크립트 파일 안에 스타일을 선언하는 방식.

`CSS-in-JS` 라이브러리 중에서 개발자들이 가장 선호하는 것이 styled-components !



styled-components와 일반 classNames를 사용하는 CSS/Sass를 비교했을 때, 가장 큰 장점은 props 값으로 전달해 주는 값을 쉽게 스타일에 적용할 수 있다는 것.



스타일을 작성할 때, ` 을 사용하여 만든 문자열에 스타일 정보를 넣어 주었는데 이 문법을 *Tagged 템플릿 리터럴* 이라고 부름.

일반 템플릿 리터럴과 다른 점: 템플릿 안에 자바스크립트 객체나 함수를 전달할 때 온전히 추출할 수 있다는 것 !



styled-components를 사용해서 **스타일링된 엘리먼트** 를 만들 땐, 컴포넌트 파일의 상단에서 styled를 불러오고 styled.태그명을 사용해서 구현함.

```react
import styled from 'styled-components'

const MyComponent = styled.div`
	font-size: 2rem;
`;
```

이렇게 styled.div 뒤에 Tagged 템플릿 리터럴 문법을 통해 스타일을 넣어 주면, 해당 스타일이 적용된 div로 이루어진 리액트 컴포넌트가 생성됨.

나중에 <MyComponent>Hello</MyComponent>와 같은 형태로 사용할 수 있음. 



styled-components를 사용하면, 스타일 쪽에서 컴포넌트에게 전달된 **props 값을 참조** 할 수 있음.

예시) `background: ${props => props.color || 'blue'};`

이 경우, background 값에 props를 조회해서 props.color의 값을 사용하게 했고, color 값이 주어지지 않았을 때는 blue를 기본 색상으로 설정함.



styled-components에서는 **조건부 스타일링**을 간단하게 props로도 처리할 수 있음 !

 

### 9.5 정리





## 10장 -> 실습 진행

### 10.1 프로젝트 준비하기



### 10.2 UI 구성하기



### 10.3 기능 구현하기



### 10.4 정리





## 11장

### 11.1 많은 데이터 렌더링하기



### 11.2 크롬 개발자 도구를 통한 성능 모니터링

크롬 개발자 도구의 Performance 탭을 사용하면, 정확히 몇 초가 걸리는지 (느려졌는지) 확인할 수 있음. 



### 11.3 느려지는 원인 분석

컴포넌트는 아래와 같은 상황에서 리렌더링(조화 과정) 발생.

- 자신이 전달받은 props가 변경될 때
- 자신의 state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- forceUpdate 함수가 실행될 때



책에서 제시한 예시에서는, 리렌더링 되어야 할 항목 말고도 수많은 항목들이 리렌더링 되어 느려지게 됨. 따라서 이럴 땐 컴포넌트 리렌덜이 성능을 최적화 해주는 작업을 해주어야 함.

즉, 리렌더링이 불필요할 땐 리렌더링을 방지하는 것이 필요 !



### 11.4 React.memo를 사용하여 컴포넌트 성능 최적화

함수형 컴포넌트에서는 shouldComponentUpdate 라는 라이프 사이클을 사용할 수 없으므로, ㄱ 대신 React.memo 라는 함수를 사용.

if) 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정해서 함수형 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있음.



### 11.5 onToggle, onRemove 함수가 바뀌지 않게 하기

현재 프로젝트에서는 todos 배열이 업데이트 되면 onRemove와 onToggle 함수는 최신 상태의 todos를 참조하기 때문에, todos 배열이 바뀔 때마다 함수가 새로 만들어짐.

이렇게 함수가 계속 만들어지는 상황을 방지하는 방법은 두 가지가 있음.

1. useState의 함수형 업데이트 기능 사용
2. useReducer 사용



- useState의 함수형 업데이트

함수형 업데이트: setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할 지 정의해 주는 업데이트 함수를 넣는 것.



- useReducer 사용하기

장점: 상태를 업데이트 하는 로직을 모아서 컴포넌트 바깥에 둘 수 있음.

단점: 기존 코드를 많이 고쳐야 함.



### 11.6 불변성의 중요성

기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 **불변성을 지킨다** 고 함.

if) 불변성이 지켜지지 않는다면, 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못함.

그렇게 된다면 React.memo에서 서로 비교하여 최적화하는 것이 불가능해짐.



### 11.7 TodoList 컴포넌트 최적화하기

리스트에 관련된 컴포넌트를 최적화 할 때는 리스트 내부에서 사용하는 컴포넌트도 최적화해야 하고, 리스트로 사용되는 컴포넌트 자체도 최적화해 주는 것이 좋음.

리스트 관련 컴포넌트를 작성할 때 리스트 아이템과 리스트, 이 두가지 컴포넌트를 최적화 해주는 것을 잊지 말기 !



### 11.8 react-virtualized를 사용한 렌더링 최적화

**react-virtualized**를 사용하면, 리스트 컴포넌트에서 스크롤되기 전에 보이지 않는 컴포넌트는 렌더링 하지 않고, 크기만 차지하게끔 할 수 있음.

만약 스크롤 되면, 해당 스크롤 위치에서 보여 주어야 할 컴포넌트를 자연스럽게 렌더링시킴.

(낭비되는 자원을 아주 쉽게 아낄 수 있음 !)



### 11.9 정리

리액트 컴포넌트의 렌더링은 기본적으로 빠르기 때문에 이 부분에 있어서 큰 스트레스를 받을 필요는 없음.

그러나, 리스트와 관련된 컴포넌트를 만들 때 보여줄 항목이 100개 이상이고 업데이트가 자주 발생한다면, 최적화하는 것이 좋음 !

