# 4주차 React 스터디 정리

| 장   | 제목                             |
| ---- | -------------------------------- |
| 9장  | 컴포넌트 스타일링                |
| 10장 | 일정 관리 웹 어플리케이션 만들기 |
| 11장 | 컴포넌트 성능 최적화             |



## 9장

CSS 스타일링

1. 일반 css   2. Sass  3. Css Module  4. styled-component

2. 일반 css

   1. 규칙 → ex. BEM네이밍
   2. CSS Selector
      1. Css 클래스가 특정 클래스 내부에 있는 경우 스타일 적용

3. Sass

   1. 정의 : CSS 전처리기 = 작업 효율성, 코드 재활용성, 가독성
   2. 확장자
      1. .scss / .sass(중괄호, 세미콜론 사용x : scss가 기존 css와 비슷하여 더 자주)
   3. 특징
      1. 파일 분리
         1. scss파일 불러올땐 import 구문
         2. 불러온 파일의 구조가 깊다면 sass-loder 설정
      2. 라이브러리 임포트 :  '~' 활용 → 자동으로 라이브러리 디렉터리 탐지

4. Css Module

   1. 정의 : CSS불러와서 사용할 때 클래스 이름을 자동으로 고유한 값 형태로 만드는 중복방지 모듈

      1. 고유한 값 ⇒  key - value 형태

         ```jsx
         		key              value
         { wrapper: "CSSModule_wrapper_1SbdQ" }
         						   파일이름_클래스이름_해시값
         ```

      2. 클래스 적용

         ```jsx
         className={styles.[클래스이름]}
         ```

   2. 글로벌 css → :global

   3. 클래스 여러개 설정/ 조건부로 클래스 설정

      1. classnames (=css클래스를 조건부로 설정할 때 유용한 라이브러리)의 bind 함수 사용

   4. 활용

      1. Sass → .module 확장자 붙여서 사용
      2. CSS Module 이 아닌 파일 → :local

5. styled-component

   1. 정의 : CSS-in-JS 라이브러리 중 하나

      1. CSS-in-JS : 자바스크립트 파일 안에 스타일을 선언하는 방법

   2. 장점

      1. .css나 .scss 확장자를 가진 스타일 파일을 따로 만들지 않아도, js파일 하나로 스타일링 가능하기때문에,
      2. props값으로 전달해주는 값을 쉽게 스타일에 적용할 수 있음

   3. 활용

      1. tagged 템플릿 리터럴

         1. 원리

            1. 템플릿에 객체나 함수를 넣으면 형태를 잃어버리는데,
            2. 함수 뒤에 템플릿 리터럴을 넣어주면 템플릿 안의 원본 값 온전 추출 가능

         2. 장점

            1. 자바스크립트 객체나 함수를 전달 할 때 온전히 추출할 수 있어서,
            2. styled-component로 만든 컴포넌트의 props를 쉽게 조회 가능함
            3. 여러 컴포넌트에서 반복되는 코드는 유틸 함수를 통해 간결하게 할 수 있음

         3. 사용

            ```jsx
            function taggend(...args) {
            	console.log(args);
            }
            tagged`hello ${{foo: 'bar' }} ${() => 'world'}!`
            ```

      2. 엘리먼트

         1. 사용

            컴포넌트 파일 상단에서

            1. styled 임포트
            2. styled.태그명

            ```jsx
            import styled from 'styled-component';
            
            const 컴포넌트명 = styled.태그명`
            	//스타일 적용
            `;
            ```

            유동적인 태그이름이나 특정 컴포넌트 자체에도 스타일링 가능

      3. props

         1. 조회 
         2. 조건부 스타일링
            1. props를 참조한다면 CSS로 감싸서 Tagged 템플릿 리터럴 사용해야 함 여러 줄의 코드에서 props를 참조 않으면 CSS를 불러와서 사용하지 않아도 ok

### 9.5 정리





## 10장 -> 실습 진행

### 10.1 프로젝트 준비하기



### 10.2 UI 구성하기



### 10.3 기능 구현하기



### 10.4 정리





## 11장

### 11.1 많은 데이터 렌더링하기



### 11.2 크롬 개발자 도구를 통한 성능 모니터링

크롬 개발자 도구의 Performance 탭을 사용하면, 정확히 몇 초가 걸리는지 (느려졌는지) 확인할 수 있음. 



### 11.3 느려지는 원인 분석

컴포넌트는 아래와 같은 상황에서 리렌더링(조화 과정) 발생.

- 자신이 전달받은 props가 변경될 때
- 자신의 state가 바뀔 때
- 부모 컴포넌트가 리렌더링될 때
- forceUpdate 함수가 실행될 때



책에서 제시한 예시에서는, 리렌더링 되어야 할 항목 말고도 수많은 항목들이 리렌더링 되어 느려지게 됨. 따라서 이럴 땐 컴포넌트 리렌덜이 성능을 최적화 해주는 작업을 해주어야 함.

즉, 리렌더링이 불필요할 땐 리렌더링을 방지하는 것이 필요 !



### 11.4 React.memo를 사용하여 컴포넌트 성능 최적화

함수형 컴포넌트에서는 shouldComponentUpdate 라는 라이프 사이클을 사용할 수 없으므로, ㄱ 대신 React.memo 라는 함수를 사용.

if) 컴포넌트의 props가 바뀌지 않았다면, 리렌더링하지 않도록 설정해서 함수형 컴포넌트의 리렌더링 성능을 최적화해 줄 수 있음.



### 11.5 onToggle, onRemove 함수가 바뀌지 않게 하기

현재 프로젝트에서는 todos 배열이 업데이트 되면 onRemove와 onToggle 함수는 최신 상태의 todos를 참조하기 때문에, todos 배열이 바뀔 때마다 함수가 새로 만들어짐.

이렇게 함수가 계속 만들어지는 상황을 방지하는 방법은 두 가지가 있음.

1. useState의 함수형 업데이트 기능 사용
2. useReducer 사용



- useState의 함수형 업데이트

함수형 업데이트: setTodos를 사용할 때 새로운 상태를 파라미터로 넣는 대신, 상태 업데이트를 어떻게 할 지 정의해 주는 업데이트 함수를 넣는 것.



- useReducer 사용하기

장점: 상태를 업데이트 하는 로직을 모아서 컴포넌트 바깥에 둘 수 있음.

단점: 기존 코드를 많이 고쳐야 함.



### 11.6 불변성의 중요성

기존의 값을 직접 수정하지 않으면서 새로운 값을 만들어 내는 것을 **불변성을 지킨다** 고 함.

if) 불변성이 지켜지지 않는다면, 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못함.

그렇게 된다면 React.memo에서 서로 비교하여 최적화하는 것이 불가능해짐.



### 11.7 TodoList 컴포넌트 최적화하기

리스트에 관련된 컴포넌트를 최적화 할 때는 리스트 내부에서 사용하는 컴포넌트도 최적화해야 하고, 리스트로 사용되는 컴포넌트 자체도 최적화해 주는 것이 좋음.

리스트 관련 컴포넌트를 작성할 때 리스트 아이템과 리스트, 이 두가지 컴포넌트를 최적화 해주는 것을 잊지 말기 !



### 11.8 react-virtualized를 사용한 렌더링 최적화

**react-virtualized**를 사용하면, 리스트 컴포넌트에서 스크롤되기 전에 보이지 않는 컴포넌트는 렌더링 하지 않고, 크기만 차지하게끔 할 수 있음.

만약 스크롤 되면, 해당 스크롤 위치에서 보여 주어야 할 컴포넌트를 자연스럽게 렌더링시킴.

(낭비되는 자원을 아주 쉽게 아낄 수 있음 !)



### 11.9 정리

리액트 컴포넌트의 렌더링은 기본적으로 빠르기 때문에 이 부분에 있어서 큰 스트레스를 받을 필요는 없음.

그러나, 리스트와 관련된 컴포넌트를 만들 때 보여줄 항목이 100개 이상이고 업데이트가 자주 발생한다면, 최적화하는 것이 좋음 !

